# STM32F103ZET6 + NT35310 TFTLCD + XPT2046触摸屏 开发调试心得

## 📋 项目概述

**硬件平台**: 正点原子战舰V3 STM32F103ZET6开发板  
**显示屏**: 3.5寸TFTLCD 320x480分辨率，NT35310驱动，16位8080并口  
**触摸屏**: XPT2046电阻式触摸控制器，软件SPI接口  
**开发环境**: STM32CubeMX + CMake + HAL库 (非Keil MDK)  

---

## 🎯 第一阶段：LCD屏幕点亮 (最关键的基础)

### 1.1 初始问题：白屏无显示

**现象**: LCD背光正常点亮，但屏幕一直显示白屏，无任何文字或图形

**我们犯过的错误分析**:

#### 错误1: CubeMX配置理解偏差
```c
// 最初的错误理解 - 我以为A16是RS线
PG0.Signal=FSMC_A16_CLE  // 错误：以为这是RS线

// 实际正确配置 - 正点原子使用A10作为RS线  
PG0.Signal=FSMC_A10      // 正确：A10才是RS线
```

**为什么犯这个错误**:
- CubeMX界面显示A16_CLE让人误解
- 没有深入理解正点原子的硬件设计
- 对FSMC地址线映射原理理解不深

#### 错误2: 地址计算公式理解错误
```c
// 我们最初的错误计算
#define LCD_RAM (0x6C000000 | (1UL << 17))  // 错误的地址偏移

// 正点原子的正确公式 
#define LCD_BASE (uint32_t)((0X60000000 + (0X4000000 * (LCD_FSMC_NEX - 1))) | (((1 << LCD_FSMC_AX) * 2) -2))
```

**调试过程记录**:
1. **第一次尝试**: 直接用CubeMX默认配置 → 白屏
2. **第二次尝试**: 修改时序参数 → 仍然白屏  
3. **第三次尝试**: 对比正点原子引脚配置 → 发现A16 vs A10的差异
4. **第四次尝试**: 修正地址计算 → 成功显示

#### 错误3: FSMC时序配置过于保守
```c
// 最初配置 - 过于保守，实际导致通信失败
FSMC.AddressSetupTime1=15    // 太长，实际应该是0
FSMC.DataSetupTime1=60       // 太长，实际应该是15
```

**为什么这样配置**:
- 以为"保守一点总是安全的"
- 不理解FSMC时序的真正含义
- 没有参考NT35310的时序要求

### 1.2 关键知识点：FSMC接口原理

#### FSMC (Flexible Static Memory Controller) 工作原理:
```
CPU -> FSMC -> 外部设备(LCD)
```

**FSMC关键参数**:
- **NE4**: 片选信号，选择Bank4 (对应0x6C000000基地址)
- **A10**: 地址线，用作LCD的RS(寄存器选择)信号
- **NOE**: 读使能 (Output Enable)
- **NWE**: 写使能 (Write Enable)  
- **D0-D15**: 16位数据总线

#### 地址计算公式 (核心知识):
```c
// 正点原子的地址计算公式
#define LCD_FSMC_NEX    4              // 使用FSMC_NE4
#define LCD_FSMC_AX     10             // 使用FSMC_A10作为RS线

// 基地址计算
#define LCD_BASE (uint32_t)((0X60000000 + (0X4000000 * (LCD_FSMC_NEX - 1))) | (((1 << LCD_FSMC_AX) * 2) -2))

// 分解说明:
// 0X60000000: FSMC Bank1基地址
// 0X4000000 * (NEX-1): 每个NE对应64MB空间，NE4对应偏移3*64MB
// (1 << AX) * 2: A10对应的地址偏移 (1024*2 = 2048)
// -2: 最终调整，确保RS=0和RS=1的地址正确对应
```

**实际调试发现**:
- 用户确认修改为A10后，问题立即解决
- 地址计算公式必须完全按照正点原子的来，不能自己"创新"

**为什么用A10作为RS线**:
- RS=0: 写命令寄存器
- RS=1: 写数据寄存器  
- 通过A10的高低电平控制RS信号
- 这样CPU可以通过不同地址访问来自动切换RS

### 1.3 FSMC时序配置 (重中之重)

#### 我们的错误配置过程:
```c
// 第一次尝试 - 太保守
Timing.AddressSetupTime = 15;      
Timing.DataSetupTime = 60;         
// 结果：无法通信

// 第二次尝试 - 还是太长
Timing.AddressSetupTime = 5;      
Timing.DataSetupTime = 30;         
// 结果：仍然无法通信

// 第三次尝试 - 参考正点原子
Timing.AddressSetupTime = 0;       // ADDSET = 0 (1 HCLK)
Timing.DataSetupTime = 15;         // DATAST = 15 (16 HCLK for read)
// 结果：成功！
```

#### 正确的时序配置:
```c
// 最终正确配置
Timing.AddressSetupTime = 0;       // ADDSET = 0 (1 HCLK)
Timing.DataSetupTime = 15;         // DATAST = 15 (16 HCLK for read)

ExtTiming.AddressSetupTime = 0;    // 写时序
ExtTiming.DataSetupTime = 1;       // DATAST = 1 (2 HCLK for write)
ExtTiming.ExtendedMode = FSMC_EXTENDED_MODE_ENABLE;  // 关键：必须启用
```

**关键错误4: ExtTiming未定义**
```c
// 编译错误
FSMC_NORSRAM_TimingTypeDef ExtTiming = {0};  // 忘记声明
if (HAL_SRAM_Init(&hsram1, &Timing, &ExtTiming) != HAL_OK)  // 传入未定义变量
```

**时序原理**:
- **AddressSetupTime**: 地址建立时间，地址稳定到控制信号有效的时间
- **DataSetupTime**: 数据建立时间，数据有效时间长度
- **ExtendedMode**: 启用读写分离时序，读慢写快

### 1.4 NT35310初始化序列

**关键发现**: NT35310需要完整的寄存器初始化序列，不能简单初始化

#### 我们的错误尝试:
```c
// 第一次尝试 - 过于简单的初始化
void lcd_init(void) {
    lcd_write_reg(0x01, 0x0000);  // 软复位
    HAL_Delay(50);
    // 就这么几行，肯定不够
}
```

#### 正确的初始化序列:
```c
// 从正点原子参考代码中提取的完整初始化序列
void lcd_ex_nt35310_reginit(void)
{
    lcd_wr_regno(0xED);
    lcd_wr_data(0x01);
    lcd_wr_data(0xFE);
    
    lcd_wr_regno(0xEE);
    lcd_wr_data(0xDE);
    lcd_wr_data(0x21);
    
    // ... 总共100多行的寄存器配置
    // 每一行都是必需的！
}
```

**调试方法**:
1. **对比法**: 将我们的代码与正点原子官方代码逐行对比
2. **参数替换**: 先用官方的参数，确认能工作后再逐步调整
3. **分段测试**: 先测试FSMC通信，再测试LCD初始化

**重要教训**: 
- 不要试图"简化"厂商提供的初始化序列
- 每个寄存器配置都有其作用，不能随意删减
- 复制粘贴成熟的代码比自己重写更可靠

---

## 🖱️ 第二阶段：XPT2046触摸屏驱动

### 2.1 触摸屏通信原理

#### 硬件连接:
```
STM32F103ZET6    XPT2046
PF10 (GPIO) <--> T_PEN    (触摸检测,低电平有效)
PF11 (GPIO) <--> T_CS     (片选,低电平有效)  
PB2  (GPIO) <--> T_MISO   (数据输入)
PF9  (GPIO) <--> T_MOSI   (数据输出)
PB1  (GPIO) <--> T_CLK    (时钟)
```

**我们的配置错误过程**:

#### 错误5: CubeMX引脚配置遗漏
```
// 初始状态：只配置了部分引脚
PF10: 已配置为GPIO Input
PF11: 已配置为GPIO Output  
PB2: 忘记配置！❌
PF9: 忘记配置！❌
PB1: 忘记配置！❌
```

**用户反馈**: "PF9和PF10配置好了，你也可以再检查一下ioc文件，但是现在还是不能触屏"

#### 软件SPI时序 (关键知识):
```c
// SPI写时序
void tp_write_byte(uint8_t data)
{
    for (count = 0; count < 8; count++)
    {
        T_MOSI(data & 0x80 ? 1 : 0);  // 设置数据线
        data <<= 1;
        T_CLK(0);                     // 时钟下降沿
        delay_us(1);                  // 建立时间
        T_CLK(1);                     // 时钟上升沿，数据锁存
        delay_us(1);                  // 保持时间
    }
}
```

**时序要点**:
- **上升沿锁存**: XPT2046在时钟上升沿锁存数据
- **延时重要性**: 必须保证足够的建立和保持时间
- **片选控制**: CS必须在整个传输过程保持低电平

### 2.2 调试过程与问题解决

#### 问题1: `bool`类型未定义
```c
// 编译错误
bool hr2046_read(uint16_t *x, uint16_t *y, uint16_t *z)  // bool未定义
```

**解决**: 添加 `#include <stdbool.h>`

#### 问题2: 触摸检测灵敏但坐标一直为0
**用户反馈**: "tst xy都有值，变化很灵敏，在右下角会接近0，在左上角接近4000，然后触摸时候T_PEN确实会变为0，RAWX/Y有变化的值，但是rawxy和T_PEN的变化延迟特别高，很卡"

**调试方法**:
```c
// 添加调试函数测试SPI通信
uint16_t tp_test_spi(void)
{
    return tp_read_ad(0XD0);  // 直接读取X轴ADC值
}

// 主循环显示调试信息
sprintf(debug_str, "PEN:%d STA:0x%04X Touch:%d", pen_status, tp_dev.sta, touch_result);
sprintf(raw_str, "TST:%04d X:%04d Y:%04d", test_adc, raw_x, raw_y);
```

**发现**: SPI通信正常，ADC值能正确读取(1000-4000范围)，但响应很慢

#### 问题3: 延时函数不准确
**错误配置**:
```c
// 第一次 - 延时倍数错误
for (i = 0; i < us * 12; i++)  // 72MHz下应该是72倍，不是12倍

// 第二次 - 延时太长，响应慢
for (i = 0; i < us * 72; i++)  // 太精确，导致响应慢

// 第三次 - 找到平衡点
for (i = 0; i < us * 18; i++)  // 适当减少获得更好的响应速度
```

#### 问题4: 测试代码影响性能
```c
// 我添加的测试代码影响了正常扫描
if (T_PEN == 0 || (test_counter % 50 == 0))  // 每50次强制读取，影响响应
```

**用户反馈**: "pen值的变化很灵敏，没什么延迟，但是坐标不显示没有变化，一直是000"

### 2.3 坐标校准算法 (五点校准法)

#### 我们的校准问题演化:

#### 错误6: 坐标方向错误
**用户反馈**: "触摸右下角时候，xy接近于0 0"

这说明坐标映射是反的！

#### 错误7: 简化校准参数不准确
```c
// 第一次尝试 - 简单线性映射，不准确
tp_dev.xfac = (float)(lcddev.width) / 4096.0f;
tp_dev.yfac = (float)(lcddev.height) / 4096.0f;

// 第二次尝试 - 硬编码经验值，仍不准确  
tp_dev.xfac = -0.074f;      // 负值表示方向相反
tp_dev.yfac = 0.098f;

// 第三次 - 正点原子的五点校准法，准确！
// 通过5个点的实际测量计算准确的转换参数
```

#### 校准原理:
```
物理坐标(ADC值) -> 屏幕坐标(像素)
```

**五点校准位置**:
1. 左上角: (20, 20)
2. 右上角: (300, 20)  
3. 左下角: (20, 460)
4. 右下角: (300, 460)
5. 中心点: (160, 240)

#### 校准参数计算:
```c
// 计算比例因子
tp_dev.xfac = (float)(s1 + s3) / (2 * (lcddev.width - 40));
tp_dev.yfac = (float)(s2 + s4) / (2 * (lcddev.height - 40));

// 中心坐标
tp_dev.xc = pxy[4][0];  // 物理中心X
tp_dev.yc = pxy[4][1];  // 物理中心Y
```

#### 坐标转换公式:
```c
// 物理坐标转换为屏幕坐标
screen_x = (signed short)(raw_x - tp_dev.xc) / tp_dev.xfac + lcddev.width / 2;
screen_y = (signed short)(raw_y - tp_dev.yc) / tp_dev.yfac + lcddev.height / 2;
```

---

## 🔧 第三阶段：系统优化与完善

### 3.1 校准参数持久化

#### 问题8: 每次上电都要重新校准
**用户反馈**: "我记得正点原子的五点校准不用很频繁，这个每次上电都要校准"

**我们的解决方案**: 使用STM32内部Flash保存校准参数

```c
// Flash保存地址 (最后一页)
#define TP_SAVE_ADDR_BASE   0x0807F000  
#define TP_SAVE_FLAG        0x0A55      // 校准标志

// 保存流程:
1. 解锁Flash
2. 擦除页面  
3. 写入标志位
4. 写入校准参数
5. 锁定Flash
```

#### 错误9: Flash操作步骤遗漏
```c
// 最初忘记了擦除步骤
HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address, data);  // 直接写入，失败

// 正确流程
HAL_FLASH_Unlock();
HAL_FLASHEx_Erase(&erase_struct, &page_error);  // 必须先擦除
HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address, data);
HAL_FLASH_Lock();
```

### 3.2 界面美化与一致性

#### 问题10: 背景色不一致
**用户反馈**: "一些字体和背景颜色有点bug，比如第一次校准，进入绘图界面，背景黑的，之后重启绘图也页就是白的"

**我们的错误分析**:
```c
// 第一次校准后
g_back_color = BLACK;  // 校准函数没有恢复背景色
lcd_clear(BLACK);

// 第二次启动  
g_back_color = WHITE;  // 初始化设置了白色
lcd_clear(WHITE);

// 导致前后不一致！
```

#### 解决方案: 统一背景色管理
```c
// 统一使用白色背景
g_back_color = WHITE;

// 校准时保存和恢复背景色
uint16_t old_back_color = g_back_color;
g_back_color = WHITE;  // 校准用白色
// ... 校准过程
g_back_color = old_back_color;  // 恢复原背景色
```

#### 颜色方案:
```c
// 统一的配色方案
标题: BLACK (黑色)
状态: BLUE (蓝色)  
错误: RED (红色)
边框: BLACK (黑色)
触摸点: RED (红色)
背景: WHITE (白色)
```

---

## 🐛 我们犯过的具体错误总结

### 编译错误类 (容易修复)
1. **`bool`类型未定义** → 添加`#include <stdbool.h>`
2. **`ExtTiming`变量未声明** → 声明`FSMC_NORSRAM_TimingTypeDef ExtTiming = {0};`
3. **`sprintf`函数未定义** → 添加`#include <stdio.h>`
4. **函数声明遗漏** → 在头文件中添加函数声明

### 配置错误类 (需要深度理解)
5. **FSMC地址线配置错误** → A16改为A10
6. **地址计算公式错误** → 采用正点原子的完整公式
7. **时序参数过于保守** → 参考官方推荐值
8. **引脚配置不完整** → CubeMX中配置所有必需引脚

### 逻辑错误类 (需要调试发现)
9. **延时函数倍数错误** → 72MHz对应正确的循环次数
10. **校准算法简化过度** → 使用完整的五点校准
11. **坐标方向映射错误** → 通过实际测试确定正确方向
12. **背景色状态不一致** → 统一的颜色管理策略

### 性能问题类 (影响用户体验)
13. **测试代码影响正常功能** → 调试完成后及时清理
14. **主循环延时过长** → 合理设置延时时间
15. **SPI通信时序过慢** → 平衡精度与速度

---

## 🔧 重要调试技巧总结

### 1. 分层调试法
```
硬件层 -> 驱动层 -> 应用层
├── 硬件连接检查 (万用表测量)
├── 时序分析 (逻辑分析仪/示波器)  
├── 寄存器配置验证
└── 功能模块测试
```

**实际应用**:
- LCD白屏：先查FSMC配置，再查初始化序列
- 触摸无响应：先查GPIO配置，再查SPI时序，最后查校准算法

### 2. 对比分析法
- **官方代码对比**: 与正点原子官方代码逐行对比
- **参数对比**: 关键参数(时序、地址、初始化序列)对比
- **工具对比**: CubeMX生成 vs 手工配置对比

**实际例子**:
- 发现A16 vs A10的差异
- 发现时序参数的差异  
- 发现初始化序列的差异

### 3. 分段验证法
```c
// LCD调试顺序
1. FSMC基本通信 -> 2. LCD ID读取 -> 3. 基本绘图 -> 4. 字体显示

// 触摸调试顺序  
1. GPIO配置 -> 2. SPI通信 -> 3. ADC读取 -> 4. 坐标转换 -> 5. 校准算法
```

### 4. 添加调试信息
```c
// 关键状态显示
sprintf(debug_str, "PEN:%d STA:0x%04X Touch:%d", pen_status, tp_dev.sta, touch_result);
sprintf(raw_str, "TST:%04d X:%04d Y:%04d", test_adc, raw_x, raw_y);

// 用户反馈作为调试依据
"tst xy都有值，变化很灵敏" → SPI通信正常
"pen值的变化很灵敏" → 硬件检测正常
"坐标不显示没有变化" → 软件处理有问题
```

### 5. 用户反馈驱动的调试法
```
用户现象描述 -> 问题定位 -> 针对性解决
```

**实际案例**:
- "白屏" → FSMC配置问题 → 修正地址和时序
- "很卡" → 延时设置问题 → 优化延时倍数
- "坐标为0" → 校准算法问题 → 采用五点校准
- "颜色不一致" → 背景色管理问题 → 统一颜色策略

---

## 💡 核心经验总结

### 1. FSMC配置要点
- **地址计算**: 理解RS线与地址线的映射关系 
- **时序配置**: 读写时序要分别优化，不要过于保守
- **ExtendedMode**: 必须启用以获得最佳性能
- **引脚复用**: 确保CubeMX中的引脚配置与硬件设计一致

### 2. 软件SPI要点  
- **时序严格**: 建立时间和保持时间都很重要
- **延时精确**: 延时函数必须准确，但不能过慢
- **错误处理**: 添加通信错误检测机制
- **性能平衡**: 在准确性和响应速度之间找平衡

### 3. 触摸校准要点
- **五点校准**: 比简单线性校准更准确，必须用成熟算法
- **参数保存**: 使用Flash保存避免重复校准  
- **边界检查**: 防止坐标越界
- **用户体验**: 提供清晰的校准界面和进度提示

### 4. 系统设计要点
- **模块化**: LCD、触摸、校准分离设计
- **容错性**: 添加超时和错误处理
- **用户体验**: 提供清晰的状态反馈
- **代码复用**: 避免重复的界面绘制代码

### 5. 调试心态要点
- **不要害怕犯错**: 错误是学习的最好机会
- **系统性分析**: 不是碰运气，而是有方法的过程
- **参考成熟方案**: 站在巨人肩膀上，不要重复造轮子
- **及时总结记录**: 好记性不如烂笔头

---

## 🎓 学习建议

### 1. 理论基础
- **STM32参考手册**: 深入理解FSMC原理
- **LCD控制器文档**: 研读NT35310数据手册
- **触摸控制器文档**: 学习XPT2046工作原理

### 2. 实践技能
- **示波器使用**: 分析时序问题的最佳工具
- **逻辑分析仪**: 数字信号调试利器
- **代码调试**: 单步调试、断点设置

### 3. 经验积累
- **多读官方例程**: 正点原子、ST官方例程
- **多做实验**: 不同参数组合的效果对比
- **多记录总结**: 问题解决过程的详细记录
- **多交流讨论**: 与有经验的开发者交流

---

## 🚀 下一步计划

1. **SD卡驱动**: 实现FatFS文件系统
2. **VS1053音频解码**: SPI通信与音频播放
3. **LVGL图形库**: 现代化UI界面  
4. **音乐播放器**: 完整的播放控制逻辑
5. **按键控制**: 硬件按键与触摸结合

---

## 📚 附录：我们的完整交流记录要点

### 关键对话节点:
1. **"目前背光点亮，呈现白屏状态"** → 开始LCD调试
2. **"仍然是白屏，我给你找了正点原子官方的操作"** → 引入官方参考
3. **"现在应经过我的对比和修改，屏幕可以显示了"** → LCD问题解决
4. **"我也去研究了一下正点原子的例程，发现几个问题"** → 开始触摸调试
5. **"tst xy都有值，变化很灵敏...但是rawxy和T_PEN的变化延迟特别高"** → 性能优化
6. **"pen值的变化很灵敏，没什么延迟，但是坐标不显示没有变化"** → 深度调试
7. **"我记得正点原子的五点校准不用很频繁"** → 校准参数保存
8. **"一些字体和背景颜色有点bug"** → 界面一致性优化

### 学习轨迹:
```
硬件理解 -> 配置掌握 -> 调试技能 -> 系统优化 -> 经验总结
```

---

**总结**: 这个项目最大的收获是理解了STM32外设配置的完整流程，特别是FSMC接口的深度应用。通过我们一起犯错、分析、解决的过程，不仅掌握了技术，更重要的是培养了系统性解决问题的能力。每一个看似简单的功能背后都有复杂的硬件原理和软件实现，而通过耐心的调试和不断的学习，我们最终都能够攻克难关。

*记住：调试不是运气，而是系统性的分析和验证过程！犯错不可怕，可怕的是不从错误中学习！*
